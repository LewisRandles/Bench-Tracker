export default async function benchTracker (apiConfig) { const se = Object.defineProperty; const pt = (t) => (e) => { const a = t[e]; if (a) return a(); throw new Error("Module not found in bundle: " + e); }; const c = (t, e) => () => (t && (e = t(t = 0)), e); const l = (t, e) => { for (const a in e)se(t, a, { "get": e[a], "enumerable": !0 }); }; const L = {}; l(L, { "errorStatus": () => oe }); let oe; const D = c(() => { oe = { "status": !0, "lastError": {}, "errorList": [] }; }); const wt = {}; l(wt, { "formError": () => ce }); async function ce (t, e) { let { "errorStatus": a } = await Promise.resolve().then(() => (D(), L)); e = e === "unknown" ? "unknown" : `${e}.js`; let n = new Error().stack.toString().match(/([A-Za-z0-9_$-]+) \(([^)]+)\)/g); n.splice(0, 2); let s = []; for await (let m of n) { let u = m.split(" "); let f = u[0]; let b = u[1].replace(/[()]/g, "").split("/"); let g = b[b.length - 1].split(":")[0]; s.push({ "function": f, "file": g }); } let o = { "code": t, "functionName": s[0].function, "currentName": s[0].file, "originalName": e }; console.log(o), t !== "warning" && (a.status = !1), a.lastError = o, a.errorList.push(o); } const ft = c(() => {}); const N = {}; l(N, { "patterns": () => le }); let le; const j = c(() => { le = { "pattern1": /[^a-zA-Z]+/g, "pattern2": /\s{2,}/g, "pattern3": /\s/g, "pattern4": /^[A-Za-z0-9]+$/i, "pattern5": /^[A-Za-z0-9\s]+$/i, "pattern6": /([Zz]|[+-]\d{2}:\d{2})$/, "pattern7": /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])(?:[Tt ]([01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?)?(?:[Zz]|[+-][01]\d:[0-5]\d)?$/, "pattern8": /^(0[1-9]|[12]\d|3[01])-(0[1-9]|1[0-2])-(\d{4})(?:[Tt ]([01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?)?(?:[Zz]|[+-][01]\d:[0-5]\d)?$/, "pattern9": /^https:\/\/members-api\.parliament\.uk(\/\S*)?$/, "pattern10": /^#?(?:[A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$/, "pattern11": /^[\p{L}][\p{L}\p{M}\s."-]*$/u, "pattern12": /^[\p{L}\p{M}][\p{L}\p{M}\s."???\-,&()/]*$/u, "pattern13": /^[\p{L}\p{M}\s()&???-]+$/u }; }); const y = {}; l(y, { "typeID": () => ue }); async function ue (t) { let { "patterns": e } = await Promise.resolve().then(() => (j(), N)); return Object.prototype.toString.call(t).split(" ")[1].replace(e.pattern1, "").toLowerCase(); } const k = c(() => {}); const P = {}; l(P, { "spaceFormat": () => me }); async function me (t, e) { let { "patterns": a } = await Promise.resolve().then(() => (j(), N)); return e === "singleSpace" ? String(t).replace(a.pattern2, " ") : e === "noSpace" ? String(t).replace(a.pattern3, "") : (await errorHandle(2414, "spaceFormat"), !1); } const O = c(() => {}); const x = {}; l(x, { "isNully": () => pe }); async function pe (t) { let { "typeID": e } = await Promise.resolve().then(() => (k(), y)); let { "spaceFormat": a } = await Promise.resolve().then(() => (O(), P)); switch (await e(t)) { case "number": return isNaN(t); case "null": case "undefined": return !0; case "string": return (await a(String(t), "singleSpace")).trim().length === 0; default: return !1; } } const S = c(() => {}); const p = {}; l(p, { "errorHandle": () => we }); async function we (t, e) { let { "errorStatus": a } = await Promise.resolve().then(() => (D(), L)); let { "formError": r } = await Promise.resolve().then(() => (ft(), wt)); let { "isNully": i } = await Promise.resolve().then(() => (S(), x)); if (await i(t)) await r("unknown", "unknown"); else { if (t === "status") return !!a.status; (await i(e)) || (t === "warning" ? await r(t, e) : t >= 1111 && t <= 9999 ? await r(t, e) : await r("unknown", "unknown")); } } const w = c(() => {}); const dt = {}; l(dt, { "conditionString": () => fe }); async function fe (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (k(), y)); let { "spaceFormat": r } = await Promise.resolve().then(() => (O(), P)); if ((await a(t)) === "string") { let i = await r(String(t), "singleSpace"); switch (String(e)) { case "1": return !0; default: return i.trim().length > 0; } } else return !1; } const ht = c(() => {}); const gt = {}; l(gt, { "conditionArray": () => de }); async function de (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (k(), y)); if ((await a(t)) === "array") switch (String(e)) { case "1": return !0; default: return t.length !== 0; } else return !1; } const yt = c(() => {}); const kt = {}; l(kt, { "conditionObject": () => he }); async function he (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (k(), y)); if ((await a(t)) === "object") switch (String(e)) { case "1": return !0; default: return Object.keys(t).length > 0 && Object.values(t).length > 0; } else return !1; } const bt = c(() => {}); const Nt = {}; l(Nt, { "conditionNumber": () => ge }); async function ge (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (k(), y)); if ((await a(t)) === "number") switch (String(e)) { case "1": return !0; default: return isNaN(t) === !1; } else return !1; } const jt = c(() => {}); const xt = {}; l(xt, { "conditionBoolean": () => ye }); async function ye (t) { let { "typeID": e } = await Promise.resolve().then(() => (k(), y)); return (await e(t)) === "boolean"; } const St = c(() => {}); const vt = {}; l(vt, { "conditionUndefined": () => ke }); async function ke (t) { let { "typeID": e } = await Promise.resolve().then(() => (k(), y)); return (await e(t)) === "undefined"; } const It = c(() => {}); const Lt = {}; l(Lt, { "conditionNull": () => be }); async function be (t) { let { "typeID": e } = await Promise.resolve().then(() => (k(), y)); return (await e(t)) === "null"; } const Dt = c(() => {}); const d = {}; l(d, { "conditionCheck": () => Ne }); async function Ne (t, e, a) { let { "conditionString": r } = await Promise.resolve().then(() => (ht(), dt)); let { "conditionArray": i } = await Promise.resolve().then(() => (yt(), gt)); let { "conditionObject": n } = await Promise.resolve().then(() => (bt(), kt)); let { "conditionNumber": s } = await Promise.resolve().then(() => (jt(), Nt)); let { "conditionBoolean": o } = await Promise.resolve().then(() => (St(), xt)); let { "conditionUndefined": m } = await Promise.resolve().then(() => (It(), vt)); let { "conditionNull": u } = await Promise.resolve().then(() => (Dt(), Lt)); switch (e) { case "string": return await r(t, a); case "array": return await i(t, a); case "object": return await n(t, a); case "number": return await s(t, a); case "boolean": return await o(t); case "undefined": return await m(t); case "null": return await u(t); } } const h = c(() => {}); const Ot = {}; l(Ot, { "flatternObject": () => Pt }); async function Pt (t, e = "", a = {}, r = new Set) { for await (let i of Object.keys(t)) { let n = t[i]; if (n && typeof n == "object" && !Array.isArray(n)) await Pt(n, i, a, r); else { let s = r.has(i) ? `${e}.${i}` : i; a[s] = n, r.add(i); } } return a; } const Ct = c(() => {}); const H = {}; l(H, { "benchNames": () => je }); let je; const B = c(() => { je = { "parents": { "item1": { "name": { "original": "bench", "altName": "bench" }, "used": !0 }, "item2": { "name": { "original": "latestHouseMembership", "altName": "membership" }, "used": !0 }, "item3": { "name": { "original": "membershipStatus", "altName": "status" }, "used": !0 }, "item4": { "name": { "original": "latestParty", "altName": "party" }, "used": !0 } }, "children": { "item1": { "name": { "original": "gender", "altName": "gender" }, "used": !0, "validate": "checkBench" }, "item2": { "name": { "original": "nameDisplayAs", "altName": "memberName" }, "used": !0, "validate": "checkBench" }, "item3": { "name": { "original": "thumbnailUrl", "altName": "thumbnailUrl" }, "used": !0, "validate": "checkBench" }, "item4": { "name": { "original": "membershipEndDate", "altName": "endDate" }, "used": !0, "validate": "checkParty" }, "item5": { "name": { "original": "membershipEndReason", "altName": "endReason" }, "used": !0, "validate": "checkParty" }, "item6": { "name": { "original": "membershipEndReasonNotes", "altName": "endReasonNotes" }, "used": !0, "validate": "checkParty" }, "item7": { "name": { "original": "membershipFrom", "altName": "location" }, "used": !0, "validate": "checkParty" }, "item8": { "name": { "original": "membershipStartDate", "altName": "startDate" }, "used": !0, "validate": "checkParty" }, "item9": { "name": { "original": "statusDescription", "altName": "description" }, "used": !0, "validate": "checkParty" }, "item10": { "name": { "original": "statusIsActive", "altName": "isActive" }, "used": !0, "validate": "checkParty" }, "item11": { "name": { "original": "statusNotes", "altName": "notes" }, "used": !0, "validate": "checkParty" }, "item12": { "name": { "original": "statusStartDate", "altName": "startDate" }, "used": !0, "validate": "checkParty" }, "item13": { "name": { "original": "abbreviation", "altName": "abbreviation" }, "used": !0, "validate": "checkMembership" }, "item14": { "name": { "original": "backgroundColour", "altName": "backgroundColour" }, "used": !0, "validate": "checkMembership" }, "item15": { "name": { "original": "foregroundColour", "altName": "foregroundColour" }, "used": !0, "validate": "checkMembership" }, "item16": { "name": { "original": "isIndependentParty", "altName": "isIndependentParty" }, "used": !0, "validate": "checkMembership" }, "item17": { "name": { "original": "isLordsMainParty", "altName": "isLordsMainParty" }, "used": !0, "validate": "checkMembership" }, "item18": { "name": { "original": "isLordsSpiritualParty", "altName": "isLordsSpiritualParty" }, "used": !0, "validate": "checkMembership" }, "item19": { "name": { "original": "name", "altName": "partyName" }, "used": !0, "validate": "checkMembership" } } }; }); const v = {}; l(v, { "patternTest": () => xe }); async function xe (t, e, a, r) { let { "errorHandle": i } = await Promise.resolve().then(() => (w(), p)); let { "patterns": n } = await Promise.resolve().then(() => (j(), N)); return n[e].test(t) ? t : (await i(a, r), !1); } const I = c(() => {}); const F = {}; l(F, { "checkGender": () => Se }); async function Se (t) { let { "isNully": e } = await Promise.resolve().then(() => (S(), x)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "patterns": r } = await Promise.resolve().then(() => (j(), N)); if (await e(t)) return "No Value"; if (t = String(t), r.pattern4.test(t)) switch (t.toLowerCase()) { case "m": return "Male"; case "f": return "Female"; default: return "Unknown"; } else return await a(6481, "checkGender"), !1; } const A = c(() => {}); const Mt = {}; l(Mt, { "checkBench": () => ve }); async function ve (t, e, a) { let { "isNully": r } = await Promise.resolve().then(() => (S(), x)); let { "patternTest": i } = await Promise.resolve().then(() => (I(), v)); let { "checkGender": n } = await Promise.resolve().then(() => (A(), F)); if (await r(e)) return "No Value"; switch (e = String(e), t) { case a.children.item2.name.altName: return await i(e, "pattern11", 5358, "checkBench"); case a.children.item1.name.altName: return await n(e); case a.children.item3.name.altName: return await i(e, "pattern9", 8242, "checkBench"); } } const Ht = c(() => {}); const Bt = {}; l(Bt, { "checkMembership": () => Ie }); async function Ie (t, e, a) { let { "isNully": r } = await Promise.resolve().then(() => (S(), x)); let { "patternTest": i } = await Promise.resolve().then(() => (I(), v)); if (await r(e)) return "No Value"; switch (e = String(e), t) { case a.children.item19.name.altName: return await i(e, "pattern13", 7808, "checkMembership"); case a.children.item13.name.altName: case a.children.item17.name.altName: case a.children.item18.name.altName: case a.children.item16.name.altName: return await i(e, "pattern4", 6252, "checkMembership"); case a.children.item14.name.altName: case a.children.item15.name.altName: return await i(e, "pattern10", 4533, "checkMembership"); } } const Ft = c(() => {}); const At = {}; l(At, { "checkParty": () => Le }); async function Le (t, e, a) { let { "patterns": r } = await Promise.resolve().then(() => (j(), N)); let { "isNully": i } = await Promise.resolve().then(() => (S(), x)); let { "patternTest": n } = await Promise.resolve().then(() => (I(), v)); if (await i(e)) return "No Value"; switch (e = String(e), t) { case a.children.item8.name.altName: case a.children.item4.name.altName: case a.children.item12.name.altName: { let s = e.replace(r.pattern6, ""); return await n(s, "pattern7", 3230, "checkParty"); } case a.children.item7.name.altName: return await n(e, "pattern12", 5633, "checkParty"); case a.children.item5.name.altName: case a.children.item6.name.altName: case a.children.item9.name.altName: case a.children.item11.name.altName: return await n(e, "pattern5", 3809, "checkParty"); case a.children.item10.name.altName: return await n(e, "pattern4", 5014, "checkParty"); } } const Rt = c(() => {}); const R = {}; l(R, { "timeDifference": () => De }); async function De (t, e) { let a; let r; let i; if (t > e ? (i = "behind", a = new Date(e), r = new Date(t)) : (i = "ahead", a = new Date(t), r = new Date(e)), isNaN(a) || isNaN(r)) return null; let n = { "years": r.getFullYear() - a.getFullYear(), "months": r.getMonth() - a.getMonth(), "days": r.getDate() - a.getDate(), "hours": r.getHours() - a.getHours(), "minutes": r.getMinutes() - a.getMinutes(), "seconds": r.getSeconds() - a.getSeconds(), "milliseconds": r.getMilliseconds() - a.getMilliseconds() }; if (n.milliseconds < 0 && (n.milliseconds += 1e3, n.seconds--), n.seconds < 0 && (n.seconds += 60, n.minutes--), n.minutes < 0 && (n.minutes += 60, n.hours--), n.hours < 0 && (n.hours += 24, n.days--), n.days < 0) { let s = new Date(r.getFullYear(), r.getMonth(), 0); n.days += s.getDate(), n.months--; } return n.months < 0 && (n.months += 12, n.years--), n.weeks = Math.floor(n.days / 7), n.days = n.days % 7, n.direction = i, n; } const $ = c(() => {}); const E = {}; l(E, { "powerDuration": () => Pe }); async function Pe (t, e) { let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), d)); let { "timeDifference": r } = await Promise.resolve().then(() => ($(), R)); let { "errorHandle": i } = await Promise.resolve().then(() => (w(), p)); let { "patterns": n } = await Promise.resolve().then(() => (j(), N)); let s; if (await a(t, "string")) if (t.toLowerCase() !== "no value")s = new Date(t).getDate() ? t : !1; else return await i(2118, "powerDuration"), !1; else return await i(5098, "powerDuration"), !1; let o; if (await a(e, "string")) if (e.toLowerCase() !== "no value")o = new Date(e).getDate() ? e : !1; else if (e.toLowerCase() === "no value")o = new Date().toISOString().replace(n.pattern11, ""); else return await i(7552, "powerDuration"), !1; else return await i(5049, "powerDuration"), !1; if (s && o) { let m = await r(s, o); return m || (await i(6367, "powerDuration"), !1); } else return await i(8531, "powerDuration"), !1; } const U = c(() => {}); const z = {}; l(z, { "nameInput": () => Oe }); async function Oe (t) { let { "spaceFormat": e } = await Promise.resolve().then(() => (O(), P)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "patternTest": r } = await Promise.resolve().then(() => (I(), v)); let i = await r(t, "pattern11", 2940, "nameInput"); if (i) { let n = (await e(String(i), "singleSpace")).toLowerCase(); return n || (await a(6201, "nameInput"), !1); } else return await a(2739, "nameInput"), !1; } const K = c(() => {}); const Z = {}; l(Z, { "modeInput": () => Ce }); async function Ce (t) { let { "spaceFormat": e } = await Promise.resolve().then(() => (O(), P)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "patternTest": r } = await Promise.resolve().then(() => (I(), v)); let i = await r(t, "pattern4", 4487, "modeInput"); if (i) { let n = (await e(String(i), "singleSpace")).toLowerCase(); return n ? n === "place" || n === "person" ? n : (await a(2721, "modeInput"), !1) : (await a(5632, "modeInput"), !1); } } const T = c(() => {}); const $t = {}; l($t, { "callObject": () => Me }); async function Me (t, e) { let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), d)); let { "errorHandle": r } = await Promise.resolve().then(() => (w(), p)); let i = (await a(t, "object")) ? t : !1; let n = (await a(e, "string")) ? e : !1; if (i && n) try { return await e.split(".").reduce(async (s, o) => s[o], t); } catch { return await r(9644, "callObject"), !1; } else return await r(3741, "callObject"), !1; } const Et = c(() => {}); const G = {}; l(G, { "manageBase": () => He }); async function He (t, e) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "callObject": r } = await Promise.resolve().then(() => (Et(), $t)); let { "conditionCheck": i } = await Promise.resolve().then(() => (h(), d)); let n = {}; let s = {}; if (!(await a("status"))) return !1; if (i(t, "object")) { for await (let o of Object.keys(e)) { if (!(await a("status"))) return !1; n[o] = !1; let m = await r(t, o); if (i(m, "string")) { let u = m.toLowerCase(); let f = await e[o](u); f && (n[o] = !0, s[o] = f); } else return await a(4278, "manageBase"), !1; } return Object.values(n).includes(!1) ? (await a(3603, "manageBase"), !1) : s; } } const Y = c(() => {}); const V = {}; l(V, { "baseInput": () => Be }); async function Be (t) { let { "nameInput": e } = await Promise.resolve().then(() => (K(), z)); let { "modeInput": a } = await Promise.resolve().then(() => (T(), Z)); let { "manageBase": r } = await Promise.resolve().then(() => (Y(), G)); return await r(t, { "mode": a, "name": e }); } const J = c(() => {}); const _ = {}; l(_, { "objectLoop": () => Ut }); async function Ut (t) { let { "typeID": e } = await Promise.resolve().then(() => (k(), y)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), d)); let { "errorHandle": r } = await Promise.resolve().then(() => (w(), p)); if (await r("status")) { if ((await a(t, "object")) === !1) return 0; let i = 0; let n = Object.keys(t); for await (let s of n) { let o = t[s]; let m = await e(o); let u; switch (m) { case "string": case "number": case "bigint": case "boolean": case "undefined": case "array": case "null": { u = await a(o, m, 1); break; } default: u = !1; }(await a(o, "object")) ? i += await Ut(o) : u && (i += 1); } return i; } else return await r(5312, "objectLoop"), !1; } const q = c(() => {}); const Q = {}; l(Q, { "resultObj": () => Fe }); async function Fe (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let a = String(t.itemData.altName); let r = t.value; let i = await t.validateImport[t.validateValue](a, r, t.nameImport[t.nameValue]); if (i) { let n = t.result; for await (let s of t.path) if (await e("status")) { let o = s; if (t.parentNames.includes(o)) { let m = t.parentList[t.parentNames.indexOf(o)]; m.used && (o = m.altName); }n[o] ? n = n[o] : n = n[o] = {}; } else return await e(5033, "resultObj"), !1; return n[t.itemData.altName] = i, t.result; } else return await e(9129, "resultObj"), !1; } const W = c(() => {}); let zt; const X = c(() => { zt = pt({ "../manageBench/benchNames.js": () => Promise.resolve().then(() => (B(), H)), "../manageBench/checkBench.js": () => Promise.resolve().then(() => (Ht(), Mt)), "../manageBench/checkGender.js": () => Promise.resolve().then(() => (A(), F)), "../manageBench/checkMembership.js": () => Promise.resolve().then(() => (Ft(), Bt)), "../manageBench/checkParty.js": () => Promise.resolve().then(() => (Rt(), At)), "../manageBench/getBench.js": () => Promise.resolve().then(() => (ot(), st)), "../manageBench/manageBench.js": () => Promise.resolve().then(() => (lt(), ct)), "../manageDate/powerDuration.js": () => Promise.resolve().then(() => (U(), E)), "../manageDate/timeDifference.js": () => Promise.resolve().then(() => ($(), R)), "../manageInput/baseInput.js": () => Promise.resolve().then(() => (J(), V)), "../manageInput/manageBase.js": () => Promise.resolve().then(() => (Y(), G)), "../manageInput/modeInput.js": () => Promise.resolve().then(() => (T(), Z)), "../manageInput/nameInput.js": () => Promise.resolve().then(() => (K(), z)), "../manageProcess/innerLoop.js": () => Promise.resolve().then(() => (M(), C)), "../manageProcess/loopItem.js": () => Promise.resolve().then(() => (nt(), at)), "../manageProcess/objectLoop.js": () => Promise.resolve().then(() => (q(), _)), "../manageProcess/resultObj.js": () => Promise.resolve().then(() => (W(), Q)), "../manageProcess/setupItem.js": () => Promise.resolve().then(() => (et(), tt)), "../manageProcess/setupLoop.js": () => Promise.resolve().then(() => (it(), rt)) }); }); let tt = {}; l(tt, { "setupItem": () => Ae }); async function Ae (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "resultObj": a } = await Promise.resolve().then(() => (W(), Q)); let r = Object.keys(t.loop.storage)[0].toLowerCase(); let i = r.charAt(0).toUpperCase() + r.slice(1); let n = r + "Names"; let s = await zt(`../manage${i}/${n}.js`); let o = t.loop.itemData.validate; let m = await zt(`../manage${i}/${o}.js`); if (await e("status")) { let u = t.loop.path; let f = t.loop.itemData; if (Number(t.loop.childIndex) === 0 && t.loop.parent !== "" && u.length === 0 && u.push(r), f) { let b = { "itemData": f, "value": t.data.value, "nameValue": n, "nameImport": s, "validateValue": o, "validateImport": m, "parentList": t.loop.parentList, "parentNames": t.loop.parentNames, "result": t.data.result, "path": u }; let g = await a(b); return g || (await e(1169, "setupItem"), !1); } else return await e(3284, "setupItem"), !1; } else return await e(5086, "setupItem"), !1; } let et = c(() => { X(); }); let at = {}; l(at, { "loopItem": () => Re }); async function Re (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), d)); let { "setupItem": r } = await Promise.resolve().then(() => (et(), tt)); let { "innerLoop": i } = await Promise.resolve().then(() => (M(), C)); for await (let n of Object.keys(t.obj)) if (await e("status")) { let s = t.obj[n]; if ((await a(s, "array")) && (s = String(s)), !(await a(s, "object")) && !(await a(s, "array"))) { let o; let m; let u; if (t.loop1.childrenNames.includes(n)) if (m = t.loop1.childrenList[t.loop1.childrenNames.indexOf(n)], m.used) { t.parent = t.parent === "" ? Object.keys(t.storage)[0] : String(t.parent); let f = { "loop": { "parent": t.parent, "storage": t.storage, "childIndex": t.childIndex.counter, "path": t.path, "itemData": m, "parentList": t.loop1.parentList, "parentNames": t.loop1.parentNames }, "data": { "value": s, "result": t.result } }; if (u = await r(f), u)o = "validPass"; else return await e(4313, "loopItem"), !1; } else o = "ignorePass"; else o = "ignorePass"; t.loop1.itemAmount.counter++, o === "validPass" ? (m.status = !0, t.result = u, t.childIndex.counter++) : o === "ignorePass" ? t.childIndex.counter++ : await e(9561, "loopItem"); } else (await a(s, "object")) && (await i(t.loop1, s, t.storage, n, t.result, t.path.concat(n))); } else return await e(8849, "loopItem"), !1; } let nt = c(() => {}); let C = {}; l(C, { "innerLoop": () => $e }); async function $e (t, e, a, r = "", i = {}, n = []) { let { "errorHandle": s } = await Promise.resolve().then(() => (w(), p)); let { "loopItem": o } = await Promise.resolve().then(() => (nt(), at)); if (await s("status")) { if (await o({ "loop1": t, "obj": e, "parent": r, "path": n, "childIndex": { "counter": 0 }, "storage": a, "result": i }), Number(a.amount) === Number(t.itemAmount.counter)) { for await (let f of Object.values(t.childrenList)) if (f.used === !0 && f.used !== f.status) return !1; return i; } } else return await s(8708, "innerLoop"), !1; } let M = c(() => {}); let rt = {}; l(rt, { "setupLoop": () => Ee }); async function Ee (t, e) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "flatternObject": r } = await Promise.resolve().then(() => (Ct(), Ot)); let { "innerLoop": i } = await Promise.resolve().then(() => (M(), C)); if (await a("status")) { let n = { "counter": 0 }; let s = {}; for await (let u of Object.keys(e.name))s[u] = {}, s[u].list = await Promise.all(Object.values(e.name[u]).map(async (f) => { let b = await r(f); return b.status = !1, b; })), s[u].name = await Promise.all(Object.values(s[u].list).map(async (f) => f.original)); let o = { "itemAmount": n, "childrenList": s.children.list, "childrenNames": s.children.name, "parentList": s.parents.list, "parentNames": s.parents.name }; let m = await i(o, t, e); return m || (await a(6336, "setupLoop"), !1); } else return await a(9171, "setupLoop"), !1; } let it = c(() => {}); const Kt = {}; l(Kt, { "valueKind": () => Ue }); async function Ue (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), d)); let r = {}; let i = {}; for await (let n of Object.keys(t))r[n] = !1; if (await a(t, "object")) { for await (let n of Object.keys(t)) { let s = t[n]; (await a(s.value, s.type)) && (r[n] = !0, i[n] = s.value); } return Object.values(r).includes(!1) ? (await e(9015, "valueKind"), !1) : i; } else return await e(9678, "valueKind"), !1; } const Zt = c(() => {}); const Tt = {}; l(Tt, { "sendProcess": () => ze }); async function ze (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), d)); let { "setupLoop": r } = await Promise.resolve().then(() => (it(), rt)); let { "valueKind": i } = await Promise.resolve().then(() => (Zt(), Kt)); if (await a(t, "object")) { let n = await i(t); if (n) { let s = Object.keys(t)[0]; let o = await r(n[s], n); return o || (await e(8361, "sendProcess"), !1); } else return await e(9122, "sendProcess"), !1; } else return await e(9122, "sendProcess"), !1; } const Gt = c(() => {}); const Yt = {}; l(Yt, { "checkResult": () => Ke }); async function Ke (t, e) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let r = t?.headers.get("content-type"); if (r && r?.includes("application/json")) try { let i = JSON.parse(e); return i || (await a(7392, "checkResult"), !1); } catch { return await a(7680, "checkResult"), !1; } else return await a(4031, "checkResult"), !1; } const Vt = c(() => {}); const Jt = {}; l(Jt, { "attemptFetch": () => Ze }); async function Ze (t) { let { "checkResult": e } = await Promise.resolve().then(() => (Vt(), Yt)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let r = 5; let i = !1; for (;r-- && i === !1;) { try { let n = await fetch(t); if (n.ok) { i = !0; let s = await n.text(); return await e(n, s); } else await a("warning", "attemptFetch"); } catch { if (r === 0) return await a(9858, "attemptFetch"), !1; } await new Promise((n) => setTimeout(n, 200)); } } const _t = c(() => {}); const qt = {}; l(qt, { "fetchBench": () => Te }); async function Te (t) { let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), d)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "attemptFetch": r } = await Promise.resolve().then(() => (_t(), Jt)); if (await e(t, "object")) { let i; switch (t.mode) { case "person": { i = encodeURI(`https://members-api.parliament.uk/api/Members/Search?Name=${t.name}&skip=0&take=1`); break; } case "place": { i = encodeURI(`https://members-api.parliament.uk/api/Location/Constituency/Search?searchText=${t.name}&skip=0&take=1`); break; } } let n = await r(i); return (await e(n, "object")) ? n : (await a(6115, "fetchBench"), !1); } else return await a(6623, "fetchBench"), !1; } const Qt = c(() => {}); let st = {}; l(st, { "getBench": () => Ge }); async function Ge (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "sendProcess": a } = await Promise.resolve().then(() => (Gt(), Tt)); let { "conditionCheck": r } = await Promise.resolve().then(() => (h(), d)); let { "objectLoop": i } = await Promise.resolve().then(() => (q(), _)); let { "fetchBench": n } = await Promise.resolve().then(() => (Qt(), qt)); let { "benchNames": s } = await Promise.resolve().then(() => (B(), H)); let { "powerDuration": o } = await Promise.resolve().then(() => (U(), E)); if (!(await e("status"))) return !1; let m = await n(t); if (m) { let u; if (t.mode === "place" ? u = m.items[0].value.currentRepresentation.member.value : t.mode === "person" && (u = m.items[0].value), await r(u, "object")) { let f = await i(u); let g = await a({ "bench": { "type": "object", "value": u }, "amount": { "type": "number", "value": f }, "name": { "type": "object", "value": s } }); if (g) { let mt = await o(g.membership.startDate, g.membership.endDate); if (mt)g.membership.duration = mt; else return await e(7166, "getBench"), !1; return g; } else return await e(5341, "getBench"), !1; } else return await e(4238, "getBench"), !1; } else return await e(3454, "getBench"), !1; } let ot = c(() => {}); let ct = {}; l(ct, { "manageBench": () => Ye }); async function Ye (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "getBench": a } = await Promise.resolve().then(() => (ot(), st)); if (!(await e("status"))) return !1; let r = await a(t); return r || (await e(4296, "manageBench"), !1); } let lt = c(() => {}); const Wt = {}; l(Wt, { "getAPI": () => Ve }); async function Ve (t) { let { "manageBench": e } = await Promise.resolve().then(() => (lt(), ct)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let r = await e(t); return (await a("status")) ? { "bench": r } : !1; } const Xt = c(() => {}); const te = {}; l(te, { "resultValue": () => Je }); async function Je (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "errorStatus": a } = await Promise.resolve().then(() => (D(), L)); return (await e("status")) ? { "status": !0, "result": t, "trace": a.errorList } : { "status": !1, "result": t, "trace": a.errorList }; } const ee = c(() => {}); const ae = {}; l(ae, { "defaultValues": () => _e }); let _e; const ne = c(() => { _e = { "mode": "person", "name": "Nigel Farage" }; }); const re = {}; l(re, { "initialValue": () => qe }); async function qe (t) { let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), d)); let { "isNully": a } = await Promise.resolve().then(() => (S(), x)); let { "errorHandle": r } = await Promise.resolve().then(() => (w(), p)); let { "defaultValues": i } = await Promise.resolve().then(() => (ne(), ae)); let n = (await a(t)) ? {} : t; let s = {}; if (await e(n, "object", 1)) { let o = Object.keys(n); let m = Object.keys(i); if (o.length <= m.length) { for await (let u of m)o.includes(u) ? s[u] = n[u] : o.includes(u) === !1 && (s[u] = i[u]); return s; } else return await r(5465, "initialValue"), !1; } else return await r(7899, "initialValue"), !1; } const ie = c(() => {}); return (async function ut (t) { let { "getAPI": e } = await Promise.resolve().then(() => (Xt(), Wt)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), d)); let { "baseInput": r } = await Promise.resolve().then(() => (J(), V)); let { "errorHandle": i } = await Promise.resolve().then(() => (w(), p)); let { "resultValue": n } = await Promise.resolve().then(() => (ee(), te)); let { "errorStatus": s } = await Promise.resolve().then(() => (D(), L)); let { "initialValue": o } = await Promise.resolve().then(() => (ie(), re)); let m = await o(t); if (await a(m, "object")) { let u = await r(m); if (!(await i("status"))) return !1; if (u) { let f = await e(u); return f ? await n(f) : (await i(7137, "benchTracker"), await n(s.lastError)); } else return await i(5976, "benchTracker"), await n(s.lastError); } else return await i(8219, "benchTracker"), await n(s.lastError); })(apiConfig); }